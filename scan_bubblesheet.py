#!/usr/bin/env python3
"""
Bubble Sheet Scanner

Processes scanned images of bubble sheets generated by generate_bubblesheet.py.
Uses the layout JSON guide rail to map bubble locations and produces a CSV with
decoded student IDs and selected answers.
"""

from __future__ import annotations

import argparse
import csv
import json
import math
import textwrap
import zipfile
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Iterator, List, Optional, Sequence, Tuple

import cv2
import numpy as np

IMAGE_EXTENSIONS = {".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp"}


@dataclass
class BubbleDef:
    label: str
    x: float
    y: float
    radius: float


@dataclass
class QuestionDef:
    number: int
    bubbles: List[BubbleDef]


@dataclass
class StudentIDColumn:
    digit_index: int
    bubbles: List[BubbleDef]


@dataclass
class LayoutGuide:
    width: float
    height: float
    questions: List[QuestionDef]
    student_id_columns: List[StudentIDColumn]
    alignment_markers: List[Dict[str, float]]
    metadata: Dict[str, float]


@dataclass
class ScanResult:
    source_name: str
    student_id: str
    answers: Dict[int, str]
    warnings: List[str]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Scan bubble sheet images and export selections to CSV.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--image", help="Path to a single scanned image.")
    group.add_argument("--folder", help="Path to a folder or .zip containing scanned images.")
    parser.add_argument("--json", required=True, help="Path to the layout JSON generated by the Bubble Sheet Generator.")
    parser.add_argument("--output", required=True, help="Destination CSV filename or prefix.")
    parser.add_argument(
        "--threshold",
        type=float,
        default=0.5,
        help="Fill ratio threshold (0-1) to consider a bubble selected.",
    )
    parser.add_argument(
        "--log",
        help="Optional log file. Defaults to <output>.log when omitted.",
    )
    parser.add_argument(
        "--output-dir",
        default="output",
        help="Directory for generated CSV/log files when using relative output paths.",
    )
    return parser.parse_args()


def load_layout(json_path: Path) -> LayoutGuide:
    with json_path.open("r", encoding="utf-8") as fp:
        data = json.load(fp)

    questions = [
        QuestionDef(
            number=item["number"],
            bubbles=[BubbleDef(label=opt["option"], x=opt["x"], y=opt["y"], radius=opt["radius"]) for opt in item["bubbles"]],
        )
        for item in data["questions"]
    ]
    student_columns = [
        StudentIDColumn(
            digit_index=col.get("digit_index") or col.get("digit"),
            bubbles=[BubbleDef(label=b["value"], x=b["x"], y=b["y"], radius=b["radius"]) for b in col["bubbles"]],
        )
        for col in data["student_id"]
    ]
    markers: List[Dict[str, float]] = []
    for marker in data.get("alignment_markers", []):
        markers.append(
            {
                "x": float(marker["x"]),
                "y": float(marker["y"]),
                "size": float(marker.get("size", 0)),
                "type": marker.get("type", "square"),
            }
        )

    dimensions = data["dimensions"]
    metadata = data.get("metadata", {})
    return LayoutGuide(
        width=float(dimensions["width"]),
        height=float(dimensions["height"]),
        questions=questions,
        student_id_columns=student_columns,
        alignment_markers=markers,
        metadata=metadata,
    )


def iter_image_sources(image_path: Optional[Path], folder_path: Optional[Path]) -> Iterator[Tuple[str, np.ndarray]]:
    if image_path:
        image = cv2.imread(str(image_path))
        if image is None:
            raise FileNotFoundError(f"Unable to read image: {image_path}")
        yield (image_path.name, image)
        return

    assert folder_path is not None
    if folder_path.is_file() and folder_path.suffix.lower() == ".zip":
        with zipfile.ZipFile(folder_path) as zf:
            for info in zf.infolist():
                if info.is_dir():
                    continue
                if not is_image_file(info.filename):
                    continue
                data = zf.read(info.filename)
                np_data = np.frombuffer(data, dtype=np.uint8)
                image = cv2.imdecode(np_data, cv2.IMREAD_COLOR)
                if image is None:
                    continue
                yield (info.filename, image)
    else:
        if not folder_path.exists():
            raise FileNotFoundError(f"Folder not found: {folder_path}")
        for file_path in sorted(folder_path.rglob("*")):
            if not file_path.is_file() or not is_image_file(file_path.name):
                continue
            image = cv2.imread(str(file_path))
            if image is None:
                continue
            rel_name = str(file_path.relative_to(folder_path))
            yield (rel_name, image)


def is_image_file(name: str) -> bool:
    return Path(name).suffix.lower() in IMAGE_EXTENSIONS


def to_top_left_coords(x: float, y: float, layout_height: float) -> Tuple[float, float]:
    return float(x), float(layout_height - y)


def order_points_clockwise(points: Sequence[Tuple[float, float]]) -> List[Tuple[float, float]]:
    pts = np.array(points, dtype=np.float32)
    rect = np.zeros((4, 2), dtype=np.float32)
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]  # top-left
    rect[2] = pts[np.argmax(s)]  # bottom-right
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)]  # top-right
    rect[3] = pts[np.argmax(diff)]  # bottom-left
    return rect.tolist()


def detect_alignment_markers(gray: np.ndarray, max_markers: int = 4) -> List[Tuple[float, float]]:
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    candidates: List[Tuple[float, float, float]] = []
    for contour in contours:
        area = cv2.contourArea(contour)
        if area < 200:
            continue
        perimeter = cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, 0.04 * perimeter, True)
        if len(approx) != 4:
            continue
        rect = cv2.minAreaRect(contour)
        width, height = rect[1]
        if min(width, height) == 0:
            continue
        aspect_ratio = max(width, height) / min(width, height)
        if aspect_ratio > 1.3:
            continue
        moments = cv2.moments(contour)
        if moments["m00"] == 0:
            continue
        c_x = moments["m10"] / moments["m00"]
        c_y = moments["m01"] / moments["m00"]
        candidates.append((area, c_x, c_y))
    candidates.sort(reverse=True, key=lambda item: item[0])
    return [(c[1], c[2]) for c in candidates[:max_markers]]


def build_layout_to_image_transform(
    layout: LayoutGuide, gray_image: np.ndarray
) -> Tuple[np.ndarray, List[str]]:
    warnings: List[str] = []
    image_h, image_w = gray_image.shape[:2]
    layout_markers = layout.alignment_markers[:4]
    detected_markers = detect_alignment_markers(gray_image) if layout_markers else []
    use_alignment = False
    matrix: Optional[np.ndarray] = None

    if len(layout_markers) == 4 and len(detected_markers) == 4:
        layout_points = []
        for marker in layout_markers:
            size = marker.get("size", 0.0)
            center_x = marker["x"] + size / 2.0
            center_y = marker["y"] + size / 2.0
            layout_points.append(to_top_left_coords(center_x, center_y, layout.height))
        layout_points_ordered = order_points_clockwise(layout_points)
        detected_ordered = order_points_clockwise(detected_markers)
        detected_arr = np.array(detected_ordered, dtype=np.float32)
        span_w = float(detected_arr[:, 0].max() - detected_arr[:, 0].min())
        span_h = float(detected_arr[:, 1].max() - detected_arr[:, 1].min())
        min_span_w = image_w * 0.4
        min_span_h = image_h * 0.4
        if span_w >= min_span_w and span_h >= min_span_h:
            matrix = cv2.getPerspectiveTransform(
                np.array(layout_points_ordered, dtype=np.float32),
                detected_arr,
            )
            use_alignment = True
        else:
            warnings.append("Detected markers cover too small an area; using proportional mapping instead.")

    if not use_alignment or matrix is None:
        if len(layout_markers) < 4:
            warnings.append("Insufficient layout markers; using proportional mapping.")
        elif len(detected_markers) < 4:
            warnings.append("Failed to detect alignment markers; using proportional mapping.")
        scale_x = image_w / layout.width
        scale_y = image_h / layout.height
        matrix = np.array(
            [
                [scale_x, 0, 0],
                [0, scale_y, 0],
                [0, 0, 1],
            ],
            dtype=np.float32,
        )
    return matrix, warnings


def transform_points(
    matrix: np.ndarray, layout_height: float, points: Sequence[Tuple[float, float]]
) -> np.ndarray:
    layout_coords = np.array(
        [[[x, layout_height - y]] for (x, y) in points],
        dtype=np.float32,
    )
    transformed = cv2.perspectiveTransform(layout_coords, matrix)
    return transformed.reshape(-1, 2)


def measure_bubble_fill(gray: np.ndarray, center: Tuple[float, float], radius: float) -> float:
    h, w = gray.shape[:2]
    mask = np.zeros((h, w), dtype=np.uint8)
    c_x = int(round(center[0]))
    c_y = int(round(center[1]))
    r = max(1, int(round(radius)))
    if c_x + r < 0 or c_x - r > w or c_y + r < 0 or c_y - r > h:
        return 0.0
    cv2.circle(mask, (c_x, c_y), r, 255, -1)
    pixels = gray[mask == 255]
    if pixels.size == 0:
        return 0.0
    return 1.0 - float(pixels.mean()) / 255.0


def estimate_pixel_radius(
    matrix: np.ndarray, layout_height: float, bubble: BubbleDef
) -> float:
    center = transform_points(matrix, layout_height, [(bubble.x, bubble.y)])[0]
    sample_points = [
        (bubble.x + bubble.radius, bubble.y),
        (bubble.x, bubble.y + bubble.radius),
    ]
    transformed = transform_points(matrix, layout_height, sample_points)
    radii = [np.linalg.norm(transformed[i] - center) for i in range(len(transformed))]
    avg_radius = float(np.mean(radii)) if radii else bubble.radius
    return max(1.0, avg_radius)


def scan_student_id(
    gray: np.ndarray,
    layout: LayoutGuide,
    matrix: np.ndarray,
    threshold: float,
) -> Tuple[str, List[str]]:
    warnings: List[str] = []
    digits: List[str] = []
    for column in sorted(layout.student_id_columns, key=lambda c: c.digit_index):
        column_scores: List[Tuple[str, float]] = []
        for bubble in column.bubbles:
            center = transform_points(matrix, layout.height, [(bubble.x, bubble.y)])[0]
            radius = estimate_pixel_radius(matrix, layout.height, bubble)
            score = measure_bubble_fill(gray, center, radius)
            column_scores.append((bubble.label, score))
        hits = [label for (label, score) in column_scores if score >= threshold]
        if len(hits) == 1:
            digits.append(hits[0])
        elif len(hits) == 0:
            best_label, best_score = max(column_scores, key=lambda item: item[1])
            warnings.append(f"Digit {column.digit_index}: no bubble above threshold (best {best_label}={best_score:.2f}).")
            digits.append("?")
        else:
            warnings.append(f"Digit {column.digit_index}: multiple selections {hits}.")
            digits.append("?")
    student_id = "".join(digits)
    if "?" in student_id or not student_id:
        warnings.append("Student ID unresolved.")
        student_id = "ERROR"
    return student_id, warnings


def scan_answers(
    gray: np.ndarray,
    layout: LayoutGuide,
    matrix: np.ndarray,
    threshold: float,
) -> Tuple[Dict[int, str], List[str]]:
    answers: Dict[int, str] = {}
    warnings: List[str] = []
    for question in layout.questions:
        option_scores: List[Tuple[str, float]] = []
        for bubble in question.bubbles:
            center = transform_points(matrix, layout.height, [(bubble.x, bubble.y)])[0]
            radius = estimate_pixel_radius(matrix, layout.height, bubble)
            score = measure_bubble_fill(gray, center, radius)
            option_scores.append((bubble.label, score))
        selections = [label for (label, score) in option_scores if score >= threshold]
        if not selections:
            best_label, best_score = max(option_scores, key=lambda item: item[1])
            warnings.append(f"Question {question.number}: no selection above threshold (best {best_label}={best_score:.2f}).")
            answers[question.number] = ""
        else:
            answers[question.number] = ",".join(sorted(selections))
    return answers, warnings


def scan_image(
    source_name: str,
    image: np.ndarray,
    layout: LayoutGuide,
    threshold: float,
) -> ScanResult:
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    matrix, transform_warnings = build_layout_to_image_transform(layout, gray)

    student_id, id_warnings = scan_student_id(gray, layout, matrix, threshold)
    answers, answer_warnings = scan_answers(gray, layout, matrix, threshold)

    warnings = [f"{source_name}: {msg}" for msg in (transform_warnings + id_warnings + answer_warnings)]
    return ScanResult(source_name=source_name, student_id=student_id, answers=answers, warnings=warnings)


def write_csv(output_path: Path, question_numbers: List[int], results: List[ScanResult]) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    headers = ["Student_ID"] + [f"Q{num}" for num in question_numbers]
    with output_path.open("w", newline="", encoding="utf-8") as fp:
        writer = csv.writer(fp)
        writer.writerow(headers)
        for result in results:
            row = [result.student_id]
            for q_num in question_numbers:
                row.append(result.answers.get(q_num, ""))
            writer.writerow(row)


def write_log(log_path: Path, entries: List[str]) -> None:
    if not entries:
        return
    log_path.parent.mkdir(parents=True, exist_ok=True)
    with log_path.open("w", encoding="utf-8") as fp:
        for entry in entries:
            fp.write(entry + "\n")


def resolve_output_paths(output_arg: str, log_arg: Optional[str], output_dir: Path) -> Tuple[Path, Path]:
    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = Path(output_arg)
    if not output_path.is_absolute():
        output_path = output_dir / output_path
    if not output_path.suffix:
        output_path = output_path.with_suffix(".csv")

    if log_arg:
        log_path = Path(log_arg)
        if not log_path.is_absolute():
            log_path = output_dir / log_path
    else:
        log_path = output_path.with_suffix(".log")
    return output_path, log_path


def main() -> None:
    args = parse_args()
    json_path = Path(args.json)
    if not json_path.exists():
        raise FileNotFoundError(f"Layout JSON not found: {json_path}")

    layout = load_layout(json_path)
    output_dir = Path(args.output_dir)
    output_path, log_path = resolve_output_paths(args.output, args.log, output_dir)

    threshold = args.threshold
    if not (0.0 < threshold <= 1.0):
        raise ValueError("threshold must be between 0 and 1.")

    image_path = Path(args.image) if args.image else None
    folder_path = Path(args.folder) if args.folder else None

    results: List[ScanResult] = []
    log_entries: List[str] = []

    for name, image in iter_image_sources(image_path, folder_path):
        try:
            result = scan_image(name, image, layout, threshold)
        except Exception as exc:  # noqa: BLE001
            log_entries.append(f"{name}: ERROR processing image ({exc}).")
            answers = {q.number: "" for q in layout.questions}
            results.append(ScanResult(source_name=name, student_id="ERROR", answers=answers, warnings=[]))
            continue
        results.append(result)
        log_entries.extend(result.warnings)

    if not results:
        raise RuntimeError("No images were processed. Please verify the provided inputs.")

    question_numbers = sorted({q.number for q in layout.questions})
    write_csv(output_path, question_numbers, results)
    write_log(log_path, log_entries)
    print(f"Created {output_path}")
    if log_entries:
        print(f"Processing warnings logged to {log_path}")


if __name__ == "__main__":
    main()
